        {
            //===========================  Finding the CHAINED INSTANCES types of the Caller Class
            // Get the inheritance of the callerClass if its type is known to process the cases where this MethodInstance is a normal kind or a kind that involves inheritance
            if (callerClass is not null && !String.IsNullOrEmpty(callerClass.type))
            {
                if(InheritanceDictionaryManager.instance.inheritanceDictionary.TryGetValue(callerClass.type, out List<string> inheritance))
                {
                    // The methodInstance must share the inherited classes with the caller class
                    this.inheritedClasses = inheritance;

                    // If the inheritance of this class has been resolved and the callerClass is NOT a MethodInstance, then get the inheritance for the next property in the property chain if this MethodInstance has any
                    if(callerClass is not MethodInstance)
                        ResolveChainedInstanceType(callerClass);
                }
            }

            //===========================  Finding the PARAMETERS and CALLER CLASS types
            // Then we resolve the parameters and class name if they are of a special kind of instance, and then we go through all of these components, and check their types, if the types are missing then we get the types
            // Putting all the components of this MethodInstance into a List to traverse them and resolve their types
            var methodInstanceComponents = new List<AbstractInstance>(calledParameters);
            if (callerClass is not null)
                methodInstanceComponents.Add(callerClass);
            for (int i = 0; i < methodInstanceComponents.Count; i++)
            {
                var currentMethodComponent = methodInstanceComponents[i];
                ResolveComponentType(currentMethodComponent);
            }

            //===========================  Finding the CHAINED INSTANCES types of the Parameters and checking if all the components of this MethodInstance are defined to look for the actual Method
            // Check if this MethodInstance knows the class parameters types, if so then proceed to find the actual Method, if not then do nothing
            bool componentsTypeKnown = true;
            for (int i = 0; i < calledParameters.Count; i++)
            {
                // If this parameter has a chained Instance, then we must find the types of all the chained instances, unless it is another MethodInstance
                if (calledParameters[i].chainedInstance is not null)
                {
                    // If this parameter is another MehtodInstance, then do nothing
                    if (calledParameters[i] is not MethodInstance)
                        ResolveChainedInstanceType(calledParameters[i]);
                    // Check if the last element has its type defined, if not then the parameters type are not known
                    if (String.IsNullOrEmpty(GetLastChainedInstance(calledParameters[i]).type))
                        componentsTypeKnown = false;
                }

                else if (String.IsNullOrEmpty(calledParameters[i].type))
                {
                    componentsTypeKnown = false;
                }
            }

            //===========================  Finding the ACTUAL METHOD
            // If the parameters type and the types of the components of the caller are known, then look into the methodDictionary the actual Method and get the return type, and also define the linkedCallsite with the actual Method
            if (componentsTypeKnown || useLooseMatchingRules)
            {
                if (MethodDictionaryManager.instance.methodDictionary.TryGetValue(this.GetMethodIdentifier(), out Method actualMethod1))
                    HandleActualMethod(actualMethod1);
                else if (kind == KindOfInstance.HasClassNameStatic)
                {
                    // If is static method, we then check the Dictionary using the className as if it was its own type
                    var backupCallerClassName = callerClass.refType.data;
                    callerClass.refType.data = callerClass.name;
                    if (MethodDictionaryManager.instance.methodDictionary.TryGetValue(this.GetMethodIdentifier(), out Method actualMethod2))
                    {
                        HandleActualMethod(actualMethod2);
                    }
                    else
                    {
                        callerClass.refType.data = backupCallerClassName;
                    }
                }
                else if (kind == KindOfInstance.IsConstructor)
                {
                    // We convert the alias class name the same as the methodName
                    this.callerClass.refType.data = methodName;

                    // And we check if there is a constructor Method tht matches this MethodINstance in the methodDictionary
                    if (MethodDictionaryManager.instance.methodDictionary.TryGetValue(this.GetMethodIdentifier(), out Method actualMethod))
                        HandleActualMethod(actualMethod);
                    // If the constructor method wasn't found, and if the parameter list has 0 elements, then this methodInstance is the default constructor and we must set the refType
                    else if(this.calledParameters.Count == 0)
                    {
                        this.refType.data = this.callerClass.type;
                        methodInstancesWithUndefinedCallsite.Remove(this);
                    }
                }
            }
        }
