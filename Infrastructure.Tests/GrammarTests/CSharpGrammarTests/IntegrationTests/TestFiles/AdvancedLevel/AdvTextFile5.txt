namespace Domain.CodeInfo.InstanceDefinitions
{
    /// <summary>
    /// An instance is a variable, parameter or method return type that has a type which we need to know when a ClassEntity calls another ClassEntity
    /// </summary>
    public abstract class AbstractInstance
    {
        public void ReceiveLocalVariableDefinition(string assignee, string? assigner, List<AbstractBuilder<AbstractInstance>>? instanceAssignerBuilders)
        {
            if (_knownInstancesDeclaredInCurrentMethodAnalysis.TryGetValue(assigner, out AbstractInstance knownAssignerInstance) && knownAssignerInstance is not MethodInstance)
            {
                var methodInstanceAssigner = ((MethodInstanceBuilder)instanceAssignerBuilders[0]).Build();
            }
        }
    }

    public void ReceiveClassEntityBuilders(List<AbstractBuilder<ClassEntity>> builders)
    {
        foreach (var builder in builders)
        {
            builder.Build();
        }
    }
}

namespace Infrastructure.Builders
{
    /// <summary>
    /// Interface to be used by classes that need to receive
    /// a certain class that was built by another with a 
    /// concrete builder
    /// </summary>
    public interface AbstractBuilder<T>
    {
        /// <summary>
        /// Returns the class built by the concrete builder
        /// </summary>
        /// <returns></returns>
        public T Build();
    }
}

namespace Infrastructure.Builders
{
    /// <summary>
    /// Instance Builder usd by the c sharp visitor just like the method instnace builder
    /// where these builders are also passed to the Mediator
    /// This Builder only focuses on one part of the method instance builder which is the 
    /// class caller, even though in this kind of objects there are no call, the class callers
    /// are the "myObject" from the "myObject.prop1.prop2[0]"
    /// This is inherited by the method instnace builder because that part of the class callers
    /// has the same processing for both builders
    /// </summary>
    public class InstanceBuilder : AbstractBuilder<AbstractInstance>
    {
        protected AbstractInstance? _callerClass = null;
        protected AbstractInstance? _callerClassChainedInstance = null;
        protected AbstractInstance? _indexRetrievalInstance = null;
        protected string? _type = null;
        protected KindOfInstance _methodInstanceKind = KindOfInstance.Normal;
        protected readonly string _paramIdentifier = "<p>";
        /// <summary>
        /// Used to get important data from the analysis of the code files which is 
        /// needed to build the methodInstance
        /// </summary>
        protected IMediator _mediator;
        /// <summary>
        /// Reado only dictionary from the mediator, used to know when there are instances with their defined type used 
        /// in a method and we must identify it
        /// </summary>
        protected IReadOnlyDictionary<string, AbstractInstance> _knownInstancesDeclaredInCurrentMethodAnalysis = new Dictionary<string, AbstractInstance>();

        public InstanceBuilder(IMediator mediator)
        {
            _mediator = mediator;
            _knownInstancesDeclaredInCurrentMethodAnalysis = mediator.GetKnownInstancesDeclaredInCurrentMethodAnalysis();
        }
        public InstanceBuilder()
        {
        }

        public AbstractInstance Build()
        {
            _callerClass.chainedInstance = _callerClassChainedInstance;
            if(_type != null)
            {
                _callerClass.kind = KindOfInstance.Normal;
                _callerClass.refType.data = _type;
            }
            AbstractInstance.GetLastChainedInstance(_callerClass).indexRetrievedInstance = _indexRetrievalInstance;
            return _callerClass;
        }
    }
}